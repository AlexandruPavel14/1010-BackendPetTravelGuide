using System.Security.Cryptography;

namespace PetTravelGuide.Backend.Utils;

public static class PasswordStorage
{
    // These constants may be changed without breaking existing hashes.
    /// <summary>
    /// Number of bytes in the encryption salt
    /// </summary>
    public const int SaltBytes = 24;

    /// <summary>
    /// Number of bytes the hash has
    /// </summary>
    public const int HashBytes = 18;

    /// <summary>
    /// Number of iterations the encryption algorithm runs
    /// </summary>
    public const int PBKDF2Iterations = 5000;

    // These constants define the encoding and may not be changed.
    /// <summary>
    /// Number of sections the hash has
    /// </summary>
    public const int HashSections = 5;

    /// <summary>
    /// The index where the hash algorithm name is stored
    /// </summary>
    public const int HashAlgorithmIndex = 0;

    /// <summary>
    /// The index where the number of iterations is stored
    /// </summary>
    public const int IterationIndex = 1;

    /// <summary>
    /// The index where the size of the hash is stored
    /// </summary>
    public const int HashSizeIndex = 2;

    /// <summary>
    /// The index where the encryption salt is stored
    /// </summary>
    public const int SaltIndex = 3;

    /// <summary>
    /// The index where the encrypted result is stored
    /// </summary>
    public const int PBKDF2Index = 4;

    /// <summary>
    /// Generates the hash
    /// </summary>
    /// <param name="password">The password string</param>
    /// <returns></returns>
    public static async Task<string> CreateHash(string password)
    {
        // Generate a random salt
        byte[] salt = new byte[SaltBytes];
        try
        {
            using RandomNumberGenerator cryptoProvider = RandomNumberGenerator.Create();
            cryptoProvider.GetBytes(salt);
        }
        catch (CryptographicException ex)
        {
            throw new Exception("Random number generator not available.", ex);
        }
        catch (ArgumentNullException ex)
        {
            throw new Exception("Invalid argument given to random number generator.", ex);
        }
        
        return await Task.Run(() =>
        {
            byte[] hash = PBKDF2(password, salt, PBKDF2Iterations, HashBytes);
            // format: algorithm:iterations:hashSize:salt:hash
            return $"sha1:{PBKDF2Iterations}:{hash.Length}:{Convert.ToBase64String(salt)}:" +
                   $"{Convert.ToBase64String(hash)}";
        }).ConfigureAwait(false);
    }

    /// <summary>
    /// Verify a password against a hash
    /// </summary>
    /// <param name="password">The password string</param>
    /// <param name="goodHash">The hash generated by <see cref="CreateHash(string)">CreateHash</see></param>
    /// <returns>True if the password corresponds, false otherwise</returns>
    public static async Task<bool> VerifyPassword(string password, string goodHash)
    {
        char[] delimiter = { ':' };
        string[] split = goodHash.Split(delimiter);
        if (split.Length != HashSections)
        {
            throw new Exception("Fields are missing from the password hash.");
        }

        // We only support SHA1 with C#.
        if (split[HashAlgorithmIndex] != "sha1")
        {
            throw new Exception("Unsupported hash type.");
        }

        int iterations;
        try
        {
            iterations = int.Parse(split[IterationIndex]);
        }
        catch (ArgumentNullException ex)
        {
            throw new Exception("Invalid argument given to Int32.Parse", ex);
        }
        catch (FormatException ex)
        {
            throw new Exception("Could not parse the iteration count as an integer.", ex);
        }
        catch (OverflowException ex)
        {
            throw new Exception("The iteration count is too large to be represented.", ex);
        }

        if (iterations < 1)
        {
            throw new Exception("Invalid number of iterations. Must be >= 1.");
        }

        byte[] salt;
        try
        {
            salt = Convert.FromBase64String(split[SaltIndex]);
        }
        catch (ArgumentNullException ex)
        {
            throw new Exception("Invalid argument given to Convert.FromBase64String", ex);
        }
        catch (FormatException ex)
        {
            throw new Exception("Base64 decoding of salt failed.", ex);
        }
        byte[] hash;
        try
        {
            hash = Convert.FromBase64String(split[PBKDF2Index]);
        }
        catch (ArgumentNullException ex)
        {
            throw new Exception("Invalid argument given to Convert.FromBase64String", ex);
        }
        catch (FormatException ex)
        {
            throw new Exception("Base64 decoding of pbkdf2 output failed.", ex);
        }
        int storedHashSize;
        try
        {
            storedHashSize = int.Parse(split[HashSizeIndex]);
        }
        catch (ArgumentNullException ex)
        {
            throw new Exception("Invalid argument given to int.Parse", ex);
        }
        catch (FormatException ex)
        {
            throw new Exception("Could not parse the hash size as an integer.", ex);
        }
        catch (OverflowException ex)
        {
            throw new Exception("The hash size is too large to be represented.", ex);
        }

        if (storedHashSize != hash.Length)
        {
            throw new Exception("Hash length doesn't match stored hash length.");
        }

        return await Task.Run(() =>
        {
            byte[] testHash = PBKDF2(password, salt, iterations, hash.Length);
            return hash.SequenceEqual(testHash);
        }).ConfigureAwait(false);
    }

    /// <summary>
    /// The PBKDF2 algorithm
    /// </summary>
    /// <param name="password">The password to encrypt</param>
    /// <param name="salt">The salt for the encryption</param>
    /// <param name="iterations">The number of iterations</param>
    /// <param name="outputBytes">The number of bytes for the output</param>
    /// <returns>The encrypted password in bytes</returns>
    private static byte[] PBKDF2(string password, byte[] salt, int iterations, int outputBytes)
    {
        using Rfc2898DeriveBytes pbkdf2 = new(password, salt)
        {
            IterationCount = iterations
        };
        
        return pbkdf2.GetBytes(outputBytes);
    }
}